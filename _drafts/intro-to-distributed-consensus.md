之前一段时间仔细学习了一些分布式一致性算法(Distributed Consensus Algorithm)，并尝试实现了一下，所以打算在这篇文章简略的介绍一下分布式算法要解决的问题、使用场景(以及不需要用的场景)、基本原理以及目前用的比较多的一些算法。

# 为什么要使用分布式一致性算法

在了解分布式一致性算法之前，我们需要搞清楚为什么我们需要它，以及在情况下我们并不需要它。

对于分布式系统，想要做到高可用(High Availability，简称HA)，一般想到的做法就是加机器，使得其中一台机器down掉也不影响服务。

在分布式系统中，一般我们会分成两类：逻辑服务和数据服务。逻辑服务指的是服务本身只处理一些业务相关的逻辑，本身并不存储数据，一般情况下业务数据都会从别的数据服务里面提取，然后处理完再存回数据服务。而数据服务是说服务本身最重要的任务就是存取数据，业务逻辑本身并不在这里实现。

对于逻辑服务，由于其并不存储数据，所以我们可以认为它们是无状态的，也就是说只要数据一样，逻辑在具体那个机器上面跑其实并不十分重要(当然有一些例外)。所以对于逻辑服务，水分拓展的方式非常简单，就是直接的加机器。

对于数据服务，想要简单的加机器并不可行。这里说的加机器，有两种方式，一种是sharding，另一种是replicate。Sharding是指通过把数据按某种方式拆分成几个区间，然后每个机器存储一个区间。Sharding方式相当于牺牲了其中某部分数据的availability(也就是当存储这个shard的机器down掉)，使得剩余数据能够做到HA，但实际上sharding并没办法做到真正的HA。

而replicate就是说把所有数据都复制一份，并存储在另几台机器上，如果其中一台机器down了，就由另外机器顶上。但实际上，数据服务要做到真正意义上的replicate，并没有大家想象中那么简单。要用replicate，首先就要求所有replica之间都拥有相同的数据，否则数据就会出现不一致。那么如何在基本所有情况下都能保证数据一致性呢？这里就需要用到分布式一致性算法来保证了。

这里说句题外话，对于某些系统来说，可能会有一个master，由master来负责协调系统内部的各种逻辑。这种系统说不上是很纯粹的数据服务，但是也不能同时由多个Master来做HA，因为这样会增加系统复杂度。在这种场景下要做到HA，就可以考虑用多个备master来做，同时只有一个master。由于并没有数据存储，所以master之间并不需要用一致性协议，只需要同一时间有一个master就可以了。这个听起来就用某种分布式锁来做就可以，而实际上可靠的分布式锁只需要用HA的一致数据服务就可以做到，比如[Zookeeper上面实现的锁][1]。

下面我们会从简单的单机开始，谈谈如何做到数据的HA。

# 单机系统到replicate

我们都知道，单机系统是最简单的，也是很容易做到一致的。因为只有一台机，所以只要系统本身是数据一致就可以。但是单机的问题也很突出，就是随着访问量的上升，系统容易成为瓶颈，而且机器down掉，整个系统就不可用了。

在这种情况下，最简单的想法就是做replicate，也就是之前所说的多台机器同时存储同样的数据。当其中一台机器down掉，就用别的机器提供服务。

这种思路在只读的情况下是可行的，可是如果要考虑写的情况，就会出问题。如果要保证数据一致性，我们必须保证每次写都能写到所有replica上面。（当然也有不写所有机器的方案，不过在这种情况会有冲突的出现，也就需要冲突解决的方案。）如下图所示：



  [1]: http://zookeeper.apache.org/doc/trunk/recipes.html#sc_leaderElection
